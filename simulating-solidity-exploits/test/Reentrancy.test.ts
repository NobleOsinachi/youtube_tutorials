import {
    time,
    loadFixture,
  } from "@nomicfoundation/hardhat-toolbox/network-helpers";
  import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
  import { expect } from "chai";
  import { ethers } from "hardhat";
  
  describe("Lock", function () {
    // We define a fixture to reuse the same setup in every test.
    // We use loadFixture to run this setup once, snapshot that state,
    // and reset Hardhat Network to that snapshot in every test.
    async function deployReentrancy() {
     
      const [owner, otherAccount] = await ethers.getSigners();
  
      const Victim = await ethers.getContractFactory("Victim");
      const victim = await Victim.deploy();

      const Attacker = await ethers.getContractFactory("Attacker");
      const attacker = await Attacker.deploy(await victim.getAddress());

    
      return { victim, attacker};
    }

    async function deployReentrancySurvivor() {
     
        const [owner, otherAccount] = await ethers.getSigners();
    
        const Survivor = await ethers.getContractFactory("Survivor");
        const survivor = await Survivor.deploy();
  
        const Attacker = await ethers.getContractFactory("Attacker");
        const attacker = await Attacker.deploy(await survivor.getAddress());
  
      
        return { survivor, attacker};
    }

    async function deployReentrancySurvivorWithGuard() {
     
      const [owner, otherAccount] = await ethers.getSigners();
  
      const Survivor = await ethers.getContractFactory("SurvivorWithGuard");
      const survivor = await Survivor.deploy();

      const Attacker = await ethers.getContractFactory("Attacker");
      const attacker = await Attacker.deploy(await survivor.getAddress());

    
      return { survivor, attacker};
  }
  
    describe("Deployment", async function () {
      it("should attack successfully", async function () {
        const { victim, attacker } = await loadFixture(deployReentrancy);
        const [account1, account2] = await ethers.getSigners();

      

        (await victim.deposit({ value: ethers.parseEther("10") })).wait();

      
        (await attacker.attack({value: ethers.parseEther("1")})).wait();

        expect(await ethers.provider.getBalance(attacker.getAddress())).to.be.equal(ethers.parseEther("10"));
      });

      it("should fail to attack the survivor", async function () {
        const { survivor, attacker } = await loadFixture(deployReentrancySurvivor);
        const [account1] = await ethers.getSigners();

        (await survivor.deposit({ value: ethers.parseEther("10") })).wait();
        // (await attacker.deposit({value: ethers.parseEther("1")})).wait();

        await expect(attacker.attack({value: ethers.parseEther("1")})).to.be.revertedWith('Failed to send Ether');

       
      });

      it("should fail to attack the survivor with Guard", async function () {
        const { survivor, attacker } = await loadFixture(deployReentrancySurvivorWithGuard);

        (await survivor.deposit({ value: ethers.parseEther("10") })).wait();
        // (await attacker.deposit({value: ethers.parseEther("1")})).wait();

        await expect(attacker.attack({value: ethers.parseEther("1")})).to.be.revertedWith('Failed to send Ether');

       
      });
    });
  });
  