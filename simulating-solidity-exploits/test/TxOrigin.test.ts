import {
    time,
    loadFixture,
  } from "@nomicfoundation/hardhat-toolbox/network-helpers";
  import { expect } from "chai";
  import { ethers } from "hardhat";
  import {BN} from "bn.js"
  
  describe("TxOrigin", function () {
    // We define a fixture to reuse the same setup in every test.
    // We use loadFixture to run this setup once, snapshot that state,
    // and reset Hardhat Network to that snapshot in every test.
    async function deployTxOriginVictim() {
     
      const [account1, account2] = await ethers.getSigners();
  
      const Victim = await ethers.getContractFactory("TxOriginVictim");
      const victim = await Victim.connect(account1).deploy();

      const Attacker = await ethers.getContractFactory("TxOriginAttacker");
      const attacker = await Attacker.connect(account2).deploy(await victim.getAddress());

    
      return { victim, attacker};
    }

    async function deployTxOriginSurvivor() {
     
        const [account1, account2, account3] = await ethers.getSigners();
        
        const Survivor = await ethers.getContractFactory("TxOriginSurvivor");
        const survivor = await Survivor.connect(account1).deploy();
  
        const Attacker = await ethers.getContractFactory("TxOriginAttacker");
        const attacker = await Attacker.connect(account3).deploy(await survivor.getAddress());
  
      
        return { survivor, attacker};
    }

   
    describe("Attacker vs Victim", async function () {
      it("should victim attack successfully", async function () {
        const { victim, attacker } = await loadFixture(deployTxOriginVictim);
        const [account1, account2] = await ethers.getSigners();
      
        const attackerBalanceBefore = await ethers.provider.getBalance(account2.getAddress());
        console.log(`Attacker Balance Before ${ethers.formatEther(attackerBalanceBefore)}`);

        (await victim.connect(account1).deposit({ value: ethers.parseEther("10") })).wait();
      
        (await attacker.connect(account1).attack()).wait();

        const attackerBalanceAfter = await ethers.provider.getBalance(account2.getAddress());
        console.log(`Attacker Balance After ${ethers.formatEther(attackerBalanceAfter)}`);

        expect(attackerBalanceAfter).to.be.equal(new BN(attackerBalanceBefore.toString()).add(new BN(ethers.parseEther("10").toString())));
      });
    });

    describe("Attacker vs Survivor", async function () {
        it("attack on the Survivor should fail", async function () {
          const { survivor, attacker } = await loadFixture(deployTxOriginSurvivor);
          const [account1, account2, account3] = await ethers.getSigners();
        
          const attackerBalanceBefore = await ethers.provider.getBalance(account3.getAddress());
          console.log(`Attacker Balance Before ${ethers.formatEther(attackerBalanceBefore)}`);
  
          (await survivor.connect(account1).deposit({ value: ethers.parseEther("10") })).wait();
        
          await expect(attacker.connect(account1).attack()).to.be.revertedWith('Insufficient balance');
          
        });
      });
  });
  